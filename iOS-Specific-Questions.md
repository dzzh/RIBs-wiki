#### Question: Why do I need to use RIBs to scope my app’s logic? Can’t I just use MVC with UIViewController hierarchies?
It is certainly possible to scope an app using MVC with `UIViewController`. The limitation is that the app’s business scopes must match with the view scopes. In a MVC world, each scope is defined entirely by the view controller. RIBs allows to have two separate and independent scope hierarchies. The business logic scopes can be defined purely by app logic states. The view scopes can be defined based on ease of UI layout, animations and transitions. The two ways of breaking down and scoping an app can be entirely independent of each other.

#### Question: How do I show things on the screen with RIBs, since I no longer use UIViewController to drive the app?
The app is driven by business logic, encapsulated by RIBs. Instead of thinking what view needs to be shown, we can consider what state the app is in. For example, if the app is in a logged out state, the RIB representing that state can then show a view(controller) that presents the necessary UI elements for the user to log in. As the app’s state changes, the corresponding RIB drives and manipulates the view hierarchy to change the UI.

#### Question: How do the object references work in RIBs? Who owns what?
In a RIBs world, a router holds strong references to an interactor and a view(controller) if the RIB has UI elements to present. If the RIB also has a presenter to encapsulate a complex business model to viewmodel transformation logic, the interactor holds a strong reference to the presenter. In the case the RIB doesn’t have the presenter, the presentation protocol is directly conformed to by the view(controller). The interactor then holds a strong reference to the view(controller). To propagate UI events back to the interactor to perform business logic and to avoid the retain cycles, the view(controller) holds a weak reference to the interactor as its listener. In order for the interactor to ask the router to perform the routing calls, the interactor holds a weak reference to its corresponding router. Finally, the builder is a factory. It does not hold any references to any other units.