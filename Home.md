RIBs is designed to avoid and withstand shortcomings of other architectures for larger teams.

These include:
* Global states and implicit dependencies cause unpredictable behavior and can make it impossible for engineers to know the full impact of their changes. Both global states and implicit dependencies are avoided where possible in RIBs.
* Global decisions, like global states, make it difficult to isolate and distribute logic. In an environment where many teams contribute changes to how our apps operate, having global decision points quickly becomes complicated as we add more teams and functionality. RIBs and streams distribute business logic and allow data to flow reactively so global decisions are used less often.
* View and application state synchronization is nondeterministic. This often occurs when state is stored locally and must be reconciled with server data and other local states.
* Components performing multiple logic types, like business and view logic, make systems difficult to understand.  RIBs perform specific sets of logic that don't blend the boundaries between business, view, and presenter logic.
* Asynchronous programming and threading is difficult to manage, especially without ways to handle, unsubscribe from, and transform results. With RIBs, ReactiveX is used to mitigate these challenges.
* Lack of compile-time safety. A capabilities-based model that passes around things with set methods makes it difficult to break things at compile time when something is no longer wired up correctly. In contrast, enforcing a specific contract declaratively means that when the contract changes or more potential operations are added, the compiler enforces that the new operations are handled.